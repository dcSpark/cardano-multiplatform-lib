"use strict";(self.webpackChunkcddl_codegen_documentation=self.webpackChunkcddl_codegen_documentation||[]).push([[953],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var d=a.createContext({}),l=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(d.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,d=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=l(n),h=s,m=u["".concat(d,".").concat(h)]||u[h]||p[h]||r;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,i=new Array(r);i[0]=h;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o[u]="string"==typeof e?e:s,i[1]=o;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9242:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var a=n(7462),s=(n(7294),n(3905));const r={sidebar_position:4},i="TransactionBuilder",o={unversionedId:"modules/builders/generating_transactions",id:"modules/builders/generating_transactions",title:"TransactionBuilder",description:"In order to simplify transaction creation, we provide a TransactionBuilder struct that manages witnesses, fee calculation, change addresses and such. Assume we have instantiated an instance under the variable builder for this explanation. The TransactionBuilder requires several protocol parameters governing Cardano to be created which is shown in the following section. These are specified initially in the genesis file for Cardano nodes.",source:"@site/docs/modules/builders/generating_transactions.mdx",sourceDirName:"modules/builders",slug:"/modules/builders/generating_transactions",permalink:"/cardano-multiplatform-lib/modules/builders/generating_transactions",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Builders",permalink:"/cardano-multiplatform-lib/category/builders"},next:{title:"CIP25",permalink:"/cardano-multiplatform-lib/modules/CIP25"}},d={},l=[{value:"Example code",id:"example-code",level:2},{value:"A note on fees",id:"a-note-on-fees",level:2}],c={toc:l},u="wrapper";function p(e){let{components:t,...n}=e;return(0,s.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"transactionbuilder"},"TransactionBuilder"),(0,s.kt)("p",null,"In order to simplify transaction creation, we provide a ",(0,s.kt)("inlineCode",{parentName:"p"},"TransactionBuilder")," struct that manages witnesses, fee calculation, change addresses and such. Assume we have instantiated an instance under the variable ",(0,s.kt)("inlineCode",{parentName:"p"},"builder")," for this explanation. The ",(0,s.kt)("inlineCode",{parentName:"p"},"TransactionBuilder")," requires several protocol parameters governing Cardano to be created which is shown in the following section. These are specified initially in the genesis file for Cardano nodes."),(0,s.kt)("p",null,"The minimum required for a valid transaction is to add inputs, outputs, time-to-live and either set the fee explicitly with ",(0,s.kt)("inlineCode",{parentName:"p"},"builder.set_fee(fee)"),", or calculate it implicitly using ",(0,s.kt)("inlineCode",{parentName:"p"},"builder.add_change_if_needed(address)"),".\nOptionally a transaction can also have certificates, reward withdrawals, and metadata added to it.\nAny change made to the builder can impact the size and thus the fee so the fee should be the last thing set.\nIf implicitly setting the fee any extra ADA (",(0,s.kt)("inlineCode",{parentName:"p"},"inputs + withdrawals - outputs + refund - deposit - min fee"),") is sent to the provided change address.\nFees must be sufficient, i.e. ",(0,s.kt)("inlineCode",{parentName:"p"},"inputs + withdrawals + refund >= outputs + deposit + fee")," which must be manually ensured if you explicitly set the fee. Any extra fee is not necessary and the extra ADA beyond that will be burned.\nOnce the transaction is ready, ",(0,s.kt)("inlineCode",{parentName:"p"},"const body = builder.build()")," can be called to return a ready ",(0,s.kt)("inlineCode",{parentName:"p"},"TransactionBody"),"."),(0,s.kt)("p",null,"Withdrawals are ADA withdrawn as part of the rewards generated by staking and deposits are refundable ADA locked while resources such as stake certificates or pool registrations exist on the blockchain. They are returned as refunds when these resources are deregistered/retired."),(0,s.kt)("p",null,"To get to a transaction ready to post on the blockchain, we must create a ",(0,s.kt)("inlineCode",{parentName:"p"},"Transaction")," from that, which consists of the ",(0,s.kt)("inlineCode",{parentName:"p"},"TransactionBody"),", a matching ",(0,s.kt)("inlineCode",{parentName:"p"},"TransactionWitnessSet")," and optionally a ",(0,s.kt)("inlineCode",{parentName:"p"},"TransactionMetadata"),".\nThe witnesses and optional metadata must match those provided to the builder. The witnesses must sign the hash of the transaction body returned by ",(0,s.kt)("inlineCode",{parentName:"p"},"hash_transaction(body)"),". In addition to the witnesses for inputs, withdrawals and some certificates require witnesses as well. For example, staking address registration does not require a witness while stake address de-registration requires one. For any questions or doubts about the rules governing fees, deposits, rewards, certificates or which witness types are required refer to the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/cardano-ledger-specs#cardano-ledger"},"shelley specs"),", specifically the Shelley design specification for general design. The formal specification could be useful for specific details as well. The design spec contains details about which certificates require which type of witnesses in the Certificates and Registrations section."),(0,s.kt)("h2",{id:"example-code"},"Example code"),(0,s.kt)("p",null,"The example below builds a transaction with all 2 of the 3 input types: key and bootstrap.\nMultisig (script) inputs are essentially identical to key inputs, but using the scripthash instead of the keyhash, however they are not supported for implicit fee calculation yet.\nFees are automatically calculated and sent to a change address in the example."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},"// instantiate the tx builder with the Cardano protocol parameters - these may change later on\nconst linearFee = CardanoWasm.LinearFee.new(\n    CardanoWasm.BigNum.from_str('44'),\n    CardanoWasm.BigNum.from_str('155381')\n);\nconst txBuilderCfg = CardanoWasm.TransactionBuilderConfigBuilder.new()\n    .fee_algo(linearFee)\n    .pool_deposit(CardanoWasm.BigNum.from_str('500000000'))\n    .key_deposit(CardanoWasm.BigNum.from_str('2000000'))\n    .max_value_size(4000)\n    .max_tx_size(8000)\n    .coins_per_utxo_word(CardanoWasm.BigNum.from_str('34482'))\n    .build();\nconst txBuilder = CardanoWasm.TransactionBuilder.new(txBuilderCfg);\n\n// add a keyhash input - for ADA held in a Shelley-era normal address (Base, Enterprise, Pointer)\nconst prvKey = CardanoWasm.PrivateKey.from_bech32(\"ed25519e_sk16rl5fqqf4mg27syjzjrq8h3vq44jnnv52mvyzdttldszjj7a64xtmjwgjtfy25lu0xmv40306lj9pcqpa6slry9eh3mtlqvfjz93vuq0grl80\");\ntxBuilder.add_key_input(\n    prvKey.to_public().hash(),\n    CardanoWasm.TransactionInput.new(\n        CardanoWasm.TransactionHash.from_bytes(\n            Buffer.from(\"8561258e210352fba2ac0488afed67b3427a27ccf1d41ec030c98a8199bc22ec\", \"hex\")\n        ), // tx hash\n        0, // index\n    ),\n    CardanoWasm.Value.new(CardanoWasm.BigNum.from_str('3000000'))\n);\n\n// add a bootstrap input - for ADA held in a Byron-era address\nconst byronAddress = CardanoWasm.ByronAddress.from_base58(\"Ae2tdPwUPEZLs4HtbuNey7tK4hTKrwNwYtGqp7bDfCy2WdR3P6735W5Yfpe\");\ntxBuilder.add_bootstrap_input(\n    byronAddress,\n    CardanoWasm.TransactionInput.new(\n    CardanoWasm.TransactionHash.from_bytes(\n        Buffer.from(\"488afed67b342d41ec08561258e210352fba2ac030c98a8199bc22ec7a27ccf1\", \"hex\"),\n    ), // tx hash\n    0, // index\n    ),\n    CardanoWasm.Value.new(CardanoWasm.BigNum.from_str('3000000'))\n);\n\n// base address\nconst shelleyOutputAddress = CardanoWasm.Address.from_bech32(\"addr_test1qpu5vlrf4xkxv2qpwngf6cjhtw542ayty80v8dyr49rf5ewvxwdrt70qlcpeeagscasafhffqsxy36t90ldv06wqrk2qum8x5w\");\n// pointer address\nconst shelleyChangeAddress = CardanoWasm.Address.from_bech32(\"addr_test1gz2fxv2umyhttkxyxp8x0dlpdt3k6cwng5pxj3jhsydzerspqgpsqe70et\");\n\n// add output to the tx\ntxBuilder.add_output(\n    CardanoWasm.TransactionOutput.new(\n    shelleyOutputAddress,\n    CardanoWasm.Value.new(CardanoWasm.BigNum.from_str('1000000'))    \n    ),\n);\n\n// set the time to live - the absolute slot value before the tx becomes invalid\ntxBuilder.set_ttl(410021);\n\n// calculate the min fee required and send any change to an address\ntxBuilder.add_change_if_needed(shelleyChangeAddress);\n\n// once the transaction is ready, we build it to get the tx body without witnesses\nconst txBody = txBuilder.build();\nconst txHash = CardanoWasm.hash_transaction(txBody);\nconst witnesses = CardanoWasm.TransactionWitnessSet.new();\n\n// add keyhash witnesses\nconst vkeyWitnesses = CardanoWasm.Vkeywitnesses.new();\nconst vkeyWitness = CardanoWasm.make_vkey_witness(txHash, prvKey);\nvkeyWitnesses.add(vkeyWitness);\nwitnesses.set_vkeys(vkeyWitnesses);\n\n// add bootstrap (Byron-era) witnesses\nconst cip1852Account = CardanoWasm.Bip32PrivateKey.from_bech32('xprv1hretan5mml3tq2p0twkhq4tz4jvka7m2l94kfr6yghkyfar6m9wppc7h9unw6p65y23kakzct3695rs32z7vaw3r2lg9scmfj8ec5du3ufydu5yuquxcz24jlkjhsc9vsa4ufzge9s00fn398svhacse5su2awrw');\nconst bootstrapWitnesses = CardanoWasm.BootstrapWitnesses.new();\nconst bootstrapWitness = CardanoWasm.make_icarus_bootstrap_witness(\n    txHash,\n    byronAddress,\n    cip1852Account,\n);\nbootstrapWitnesses.add(bootstrapWitness);\nwitnesses.set_bootstraps(bootstrapWitnesses);\n\n// create the finalized transaction with witnesses\nconst transaction = CardanoWasm.Transaction.new(\n    txBody,\n    witnesses,\n    undefined, // transaction metadata\n);\n")),(0,s.kt)("h2",{id:"a-note-on-fees"},"A note on fees"),(0,s.kt)("p",null,"Fees is Cardano Shelley are based directly on the size of the final encoded transaction. It is important to note that a transaction created by this library potentially can vary in size compared to one built with other tools. This is because transactions, as well as other Cardano Shelley structures, are encoded using ",(0,s.kt)("a",{parentName:"p",href:"https://cbor.io/"},"CBOR")," a binary JSON-like encoding. Due to arrays and maps allowing both definite or indefinite length encoding in the encoded transaction created by the library, the size can vary. This is because definite encoding consists of a tag containing the size of the array/map which can be 1 or more bytes long depending on the number of elements the size of the encoded structure, while indefinite length encoding consists of a 1 byte starting tag and after all elements are listed, a 1 byte ending tag. These variances should should only be a couple bytes and cardano-multiplatform-lib uses definite encoding which is the same length or smaller for any reasonable sized transaction."))}p.isMDXComponent=!0}}]);